# Requirements

- [ ] 支持同时进行多个样本序列的采样

- [ ] 订单提前期、运输提前期都要体现
例如：订单提前期`LO`为
```json
{
    "(1,2)": {
        "A": "func1",
        "B": "func2"
    }
}
```
表示:
  - 从1向2节点供应物料时，A物料的订单由函数func1决定，B物料的订单提前期由函数func2决定. 

_运输提前期 LS的格式同LO_

- [ ] 节点不同成品处理时间和原材料配比
```json
{
    "3": {
        "C": { 
            "component": {
                "A": 2,
                "B": 1
            },
            "process_time":2
        }
    }
}
```
表示:
  - 在3节点把A材料B材料加工成C材料（或产品），每单位C产品，消耗2单位的A材料和1单位的B材料
  - 处理时间为2

- [ ] 能够输出每个周期期初、期末各种变量的信息

- [ ] 每个节点每个周期的状态变量包含且不限于:
  - 在途库存
  - 在手库存
  - :smoking: （期初？）到达数量
  - :smoking: （期末？）送出数量
  - 向上级各节点的下单量
  - 收到各下级节点的订单量
  - 对下级各节点的缺货累积量

- [ ] 支持任意网络类型，网络结构由有连接关系的边（edges）的信息确定，输入数据格式为
     edges:
```json
{
    "(1,2)": ["A", "B"],
    "(1,3)": ["A"]
}
```
表示:
  - 其中key为边的起始节点和到达节点组成的元组，value为该边上供应的物料数组
  - 不允许有环

- [ ] 当在手库存不足时，而有多个下游子节点时，物料分配方案可以配置

- [ ] 最上游节点的需求默认为立即满足

- [ ] 各个节点对各个上游材料的持有成本、对各个下游的缺货成本都可配置为一个函数（不一定是线性的）
   持有成本   H:
```json
{
    "1": {
        "A": "h_func1",
        "B": "h_func2"
    },
    "2": {
        "A": "h_func3",
        "B": "h_func4"
    }
}
```
表示:
  - 在节点1，A物料的持有成本由h_func1决定，B物料的持有成本由h_func2决定
  - 在节点2，A物料的持有成本由h_func3决定，B物料的持有成本由h_func4决定

_`缺货成本P`的格式同 `H`_

- [ ] 各个最下游节点对每种物料的需求可以由一个随机函数表示（不一定是正态的）
    D：
```json
{
    "7": {
        "A": "d_func1",
        "B": "d_func2"
    },
    "8": {
        "A": "d_func3",
        "B": "d_func4"
    }
}
```
表示:
  - 在节点7，A物料的持有成本由d_func1决定，B物料的持有成本由d_func2决定
  - 在节点8，A物料的持有成本由d_func3决定，B物料的持有成本由d_func4决定

- [ ] 仿真周期数可以配置

- [ ] 各个节点在最终仿真结束时的残值成本函数可配置 :question: :question: :question:
    S：
```json
{
    "7": {
        "A": "s_func1",
        "B": "s_func2"
    },
    "8": {
        "A": "s_func3",
        "B": "s_func4"
    }
}
```
表示:
  - 在节点7，A物料在最终仿真结束时的残值成本由d_func1决定，B物料在最终仿真结束时的残值成本由d_func2决定
  - 在节点8，A物料在最终仿真结束时的残值成本由d_func3决定，B物料在最终仿真结束时的残值成本由d_func4决定

- [ ] 原材料库存和成品库存需要分别考虑，原材料经过process time 变成成品

- [ ] 如果是组装关系。那么需要考虑，原材料和成品之间的装备比例，例如3A+4B ->product1。
  - 一个节点如果有两个上游节点，这两个上游节点给它的可能是不同的原材料
  - 而它如果有两个下有节点，它给这两个节点的产品是一样的
  - 所以有几个上游节点，就需要有几个独立的原材料库存

- [ ] 如果多个上游供应的是同一种物料。那么可以公用同一个库存。向不同上级节点订货的数值可以由多个模型分别输出。

# 仿真

## Init
- [ ] 初始化各节点各种物料库存水平， 本期库存水平， 缺货积压量； 各边的在途物料量

## Step & State
在每一个周期，仿真器运行一次step功能，并输出state和reward相关信息。

### step要做的事情
- [ ] 返回各种状态信息：包括各个节点各种物料的 库存水平、积压缺货订单量， 各个边上的 在途库存量
- [ ] 接收agent生成的各个节点各个物料的订货量，发起订单 
- [ ] （中间节点）生产需要生产的物料， 即 “当前周期点 - 订单发出周期点 == LT” 的物料， 并记录由生产造成的物料消耗。
- [ ] （中间节点）记录生产完成的物料量 即 “当前周期点 - 生产开始周期点 == PT” 的物料。 
- [ ] （最上游节点和中间节点）直接下游的各种物料，发出到期订单的物料，即 ”当前周期点 - 订单发出周期点 == LO“ 的 订单；
  发货物料加入在途物料列表中。 对于最上游节点，不存在缺货情况。  对于中间节点，需要记录缺货情况和真实发货数量。
- [ ] （中间节点）对于各个中间节点，针对各个直接上级上各种物料，接收到期订单的物料，即 ”当前周期点 - 订单发出周期点 == 
  LO + LS“ 且 “当前周期点 - 发货周期点 == LS” 的 订单；已接收物料移除在途物料库存列表。
- [ ] （最下游节点）对于各种物料， 立即发出数量为 min(需求量，库存水平)的物料， 并记录 发货量和缺货量
- [ ] 更新各种物料库存水平， 本期库存水平 = 上周期库存水平 + 生产产出量 + 到货量 - 生产消耗量 - 发货量
- [ ] 针对各个直接下游的各种物料，更新 缺货积压订单列表
- [ ] （大多数情况下只针对末级节点）计算缺货成本 = 缺货量*p_func
- [ ] 计算物料持有持有成本增加值， 物料持有成本增加值 = 物料库存水平 * h_func
- [ ] 计算在途成本增加值，运输成本分摊到LS个周期上，所以本周期物料的运输成本增加值=总的在途成本/LS
- [ ] 针对末级节点计算收入 收入增加值 = 发货量*price
- [ ] 返回 收入增加值、在途成本增加值、持有成本增加值

## finish
- [ ] 返回 残值成本


